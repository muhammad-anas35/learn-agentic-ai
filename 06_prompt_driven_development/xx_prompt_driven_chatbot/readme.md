# Prompt‑Driven Chatbot with OpenAI Agents SDK (Cursor + uv)
**PDD × TDD × ADR × PR Edition**

> Build a production‑ready chatbot **without writing a single line of code by hand**—we’ll make Cursor do the typing while you keep the big brain energy. It’s vibe coding **but with a suit on**: prompts define the work, tests guard the work, ADRs explain the work, and PRs gate the work.



---

## Who this is for
You want to develop a Python chatbot using the **OpenAI Agents SDK** while **only writing prompts** (and the occasional terminal command), letting **Cursor** generate all code and files. You’ll use **uv** for dependency management because life is too short for slow installs.

**Outcome:** a working, testable chatbot (FastAPI backend + multi‑agent orchestration) generated by prompts—plus a Docker image, CI, **tests (TDD)**, **Architecture Decision Records (ADRs)**, and a **Pull Request (PR)** workflow.

---

## Tools you’ll use (and how they play together)
- **Cursor**: your code co‑author. You provide **prompts**, it produces files, diffs, and commits.
- **OpenAI Agents SDK (Python)**: minimal primitives—**Agents**, **Tools**, **Sessions**, **Handoffs**, **Guardrails**.
- **uv** (Astral): blazing‑fast Python package & project manager.
- **pytest + ruff**: tests and lint.
- **GitHub Actions** (or similar): CI to enforce “no green, no merge.”

> Put official docs/links inside prompts so Cursor uses the right APIs—less spaghetti, fewer tears.

---

## One‑time setup inside Cursor: your house rules
Before any prompting session, set these **workspace rules** so Cursor stays on‑track.

**Action:** Open **Cursor → Settings → Rules for AI** and paste:

### Workspace Rules (paste as your global rules)
```text
# Project guardrails
- Python 3.12+ and uv for project + dependency management.
- Use OpenAI Agents SDK (Python) for agent logic.
- Scaffold FastAPI with /healthz and /chat endpoints.
- Use .env with OPENAI_API_KEY; never hardcode secrets.
- Add tests with pytest; mock network calls by default (offline CI).
- Enforce type hints and static checks (ruff, mypy‑friendly code).
- Prefer small, composable modules; document public modules.
- Use uv‑based multi‑stage Docker; minimize runtime image size.

# File hygiene
- README.md with exact run commands and curl examples.
- .env.sample, .gitignore, .dockerignore.
- **docs/adr** folder with ADR template and incremental ADRs.
- **.github/pull_request_template.md** requiring tests + ADR link when interfaces/deps change.

# Agent design defaults
- Start with CustomerAgent; add ResearchAgent with handoffs.
- Sessions for chat continuity.
- Two function tools minimum (calculator, datetime).
- Guardrail via Pydantic output type.
- Streaming via SSE; WebSocket optional later.

# Quality bar (policy)
- Code must run end‑to‑end after `uv sync`.
- Tests first (TDD): Red → Green → Refactor.
- CI requires: ruff, pytest, coverage ≥ 80%, Docker build.
- **PR gate:** small scope, tests included, ADR linked if public API or deps change. No green, no merge.
```

> Keep rules under ~500 lines. If you go over, Cursor will sigh in YAML.

---

## PDD in baby steps (sequential prompts)
**Prompt‑Driven Development is incremental.** Each step is a **focused prompt**; the **AI writes the code**. Now add **TDD** so every step is verified.

### The PDD × TDD loop (suit + tie)
1. **Plan (PDD)** — *Architect prompt*: tiny outcome, constraints, acceptance checks.
2. **Red (TDD)** — *Tests‑only prompt*: add failing tests encoding the criteria.
3. **Green (PDD)** — *Minimal‑diff prompt*: implement the smallest change to pass tests.
4. **Refactor (TDD)** — *Refactor prompt*: clean internals, keep tests green.
5. **Explain (PDD)** — *Explainer prompt*: summarize diffs/trade‑offs.
6. **Record (PDD)** — *ADR prompt*: document context, options, decision, consequences.
7. **Share (Team)** — open a **PR** linking tests + ADR; CI must pass.

### Example micro‑steps (prompts only)
- **Step 1: Health check**  
  *Red:* “Add failing test `tests/test_healthz.py::test_healthz_ok` expecting `{status:'ok'}`.”  
  *Green:* “Create `GET /healthz` to pass the test; update README with curl. Minimal diff.”
- **Step 2: Non‑streaming `/chat`**  
  *Red:* “Add contract tests for 200 and 400 when `user_message` is missing.”  
  *Green:* “Implement `POST /chat {session_id, user_message}` using the Agents SDK; return `{text, used_tool, handoff}`.”
- **Step 3: Streaming (SSE)**  
  *Red:* “Add tests for SSE content‑type and event format; mock stream.”  
  *Green:* “Extend `/chat` to support SSE; preserve non‑streaming fallback; document curl example.”
- **Step 4: Tools**  
  *Red:* “Tests asserting `calculator` and `now` tools work and usage is surfaced.”  
  *Green:* “Add `@function_tool` `calculator(expression)` and `now(tz)`; register on agent.”
- **Step 5: Guardrails**  
  *Red:* “Tests: responses conform to `ChatReply`; reject >1200 chars with one retry.”  
  *Green:* “Use `output_type=ChatReply` with Pydantic; implement retry on validation failure.”
- **Step 6: Handoff**  
  *Red:* “Tests for intent classifier thresholds and `handoff_reason` surfaced.”  
  *Green:* “Add `ResearchAgent`; handoff when intent=RESEARCH (confidence ≥0.7).”

> After each green run, **commit the delta**. Open a **PR** for each vertical slice and link the related **ADR**.

---

## Phase 1 — Bootstrap the project (Cursor does everything)
You’ll **paste prompts** into Cursor’s Composer (⌘I) or Chat panel. Cursor proposes diffs; you approve.

### Prompt 1 — Project scaffold with uv + tests/ADR/PR plumbing
**Paste into Cursor:**
```text
Create a new Python project `agents-chatbot` using uv. Tasks:
1) Init uv project (pyproject.toml), Python 3.12+.
2) Add deps: openai-agents, fastapi, uvicorn[standard], pydantic, python-dotenv, httpx, pytest, ruff.
3) Structure:
   - app/main.py (FastAPI with /healthz)
   - app/agents/core.py (base agent factory, Sessions enabled)
   - app/agents/tools.py (calculator + datetime via function_tool)
   - app/agents/customer.py (CustomerAgent instructions)
   - app/agents/research.py (ResearchAgent + handoffs)
   - app/guards/schemas.py (Pydantic output types)
   - app/guards/rules.py (simple guardrail example)
   - app/config.py (dotenv; configurable model)
   - tests/ (smoke + contract tests skeleton)
   - docs/adr/ (include `0000-template.md`)
4) .env.sample with OPENAI_API_KEY, MODEL
5) README with uv commands, run instructions, curl examples
6) Makefile: run, test, lint, format, coverage
7) CI: .github/workflows/ci.yml → uv sync, ruff, pytest, coverage ≥80%, docker build
8) PR template: .github/pull_request_template.md → requires tests + ADR links when interfaces/deps change
Return exact uv commands to run locally.
```

**Explain the generated code**
- **uv** for speed & reproducibility.  
- **Tests/CI** from day one enables TDD.  
- **ADR folder + PR template** bake traceability and review discipline into the workflow.

---

## Phase 2 — Core agent with tools + sessions
We’ll wire an **Agent** with **tools** and **Sessions** so conversations have memory.

### Prompt 2 — Base Agent and tools (with tests first)
**Paste into Cursor:**
```text
RED: Add tests for an Agent named "CustomerAgent" that defers to tools for math/datetime and uses Sessions per session_id.
GREEN: Implement app/agents/core.py to construct the Agent and expose get_runner() for streaming. Implement app/agents/tools.py with two @function_tool functions: calculator(expression) and now(tz|None). Register tools on the agent.
```

**Explain the generated code**
- **Agent** bundles model + instructions + tools.  
- **Tools** are callable capabilities; SDK derives JSON schemas.  
- **Sessions** avoid manual history handling.

---

## Phase 3 — FastAPI endpoints + streaming chat (TDD gates)

### Prompt 3 — REST + streaming (Red → Green)
**Paste into Cursor:**
```text
RED: Add failing tests for /chat non-streaming (200 + 400) and SSE streaming (content-type, event format). Include mocks.
GREEN: Implement endpoints to pass tests. Provide a ChatService that manages session + Runner.run(...). Keep changes minimal; no unrelated refactors. Explain changes and update README curl examples.
Create ADR `0002-streaming-choice-sse` with context, alternatives (WebSocket/polling), decision, consequences.
Open a PR linking tests and ADR; ensure CI is green.
```

**Why this order**
- **Red first** defines behavior before code.  
- **ADR** documents “why SSE,” aiding future maintenance.

---

## Phase 4 — Multi‑agent handoffs (tested & documented)

### Prompt 4 — ResearchAgent + handoff logic with tests
**Paste into Cursor:**
```text
RED: Add tests for intent classification thresholds and presence of `handoff_reason` in logs/response.
GREEN: Implement ResearchAgent and handoff from CustomerAgent when intent=RESEARCH with confidence ≥0.7. Document the sequence (diagram) and write ADR `0003-handoff-strategy` capturing thresholds and alternatives. Open a PR linking tests + ADR; keep the diff minimal.
```

**Outcome**
- Observable, testable handoffs with clear rationale and reviewer‑visible scope via PR.

---

## Phase 5 — Guardrails (light but mighty, enforced by tests)

### Prompt 5 — Output shape + length constraints via tests
**Paste into Cursor:**
```text
RED: Add tests ensuring final replies conform to Pydantic `ChatReply {text, used_tool, handoff}` and reject >1200 chars with one retry.
GREEN: Enforce `output_type=ChatReply` in Agent config and implement guardrail; add single retry on validation failure. Explain changes. Write ADR `0004-output-shape-and-limits`. Open a PR with passing CI.
```

**Benefit**
- Structured outputs simplify frontend integration; tests prevent regressions.

---

## Phase 6 — Observability & tracing (optional but classy)

### Prompt 6 — Add tracing hooks
**Paste into Cursor:**
```text
Instrument with the Agents SDK tracing utilities so each /chat call produces spans for tools and handoffs. Add docs/observability.md explaining how to enable, view, and filter traces locally. Add tests/mocks so tracing does not require network calls.
```

**Explain the generated code**
- Tracing reveals agent steps; helpful for debugging and demos.  
- Keep PII out of traces.

---

## Phase 7 — Dockerize with uv (small images, big smiles)

### Prompt 7 — Create a uv‑based Dockerfile (+ ADR)
**Paste into Cursor:**
```text
Create Dockerfile + .dockerignore:
- Multi-stage build using uv
- Build stage: sync deps (pyproject + uv.lock); run tests
- Final stage: copy app and environment; run `uv run uvicorn app.main:app --host 0.0.0.0 --port 8000`
Add `make docker-build` and `make docker-run`.
Write ADR `0005-docker-strategy-uv` explaining footprint/security trade-offs.
Open a PR with image size note and CI passing.
```

**Why**
- Smaller images, faster deploys, and documented rationale future teammates can trust.

---

## Phase 8 — Smoke tests, CI, and PR policy

### Prompt 8 — Tests & CI hardening
**Paste into Cursor:**
```text
Add pytest tests for /healthz, /chat (non-streaming + SSE), and mocked tool calls. Ensure tests run offline.
CI: uv sync, ruff, pytest with coverage ≥80%, build Docker image.
Add a PR policy doc: small scope, tests required, ADR link when interfaces/deps change, “no green, no merge,” screenshots or curl examples for APIs.
```

**Outcome**
- Deterministic CI, clear review gates, and traceable decisions via ADRs.

---

## Phase 9 — Product polish

### Prompt 9 — README & ADRs
**Paste into Cursor:**
```text
Expand README with Quickstart (uv commands), API examples (curl), architecture diagram, and troubleshooting.
Add docs/adr/0001-architecture.md describing agents, tools, sessions, handoffs, guardrails.
```

**Explain the generated content**
- Clear docs reduce onboarding time.  
- ADRs capture **why**—not just **what**—so decisions age well.

---

## Bonus: Prompt patterns you’ll reuse (copy/paste gold)

### Architect (micro-spec)
```text
You are the software architect. Design <feature> as a minimal slice. Provide goals, constraints, public interfaces, Given/When/Then acceptance tests, risks, and an ADR draft summarizing decision and alternatives.
```

### Red (tests only)
```text
Add failing tests for <behavior>. Include edge/negative cases and clear names. No production code changes. Keep the diff minimal and runnable offline.
```

### Green (smallest diff)
```text
Make the smallest change necessary to pass tests/<path>::<test_name>. Do not refactor unrelated code. No new dependencies. Output diff-only.
```

### Refactor (safety rails)
```text
Refactor internals for clarity/performance. Preserve public APIs and behavior. All tests must remain green. Provide a short refactor summary.
```

### ADR (why this way)
```text
Create ADR <id-title> with: Context, Options (pros/cons), Decision, Consequences, References. Status = Accepted. Link to related PR and tests.
```

### PR (team gate)
```text
Draft a PR description: problem/solution, screenshots or curl, linked ADRs/issues, test plan, rollout notes, and risk assessment. Keep scope small.
```

---

## Teaching tips (how to run the class)
- **Students only paste prompts** into Cursor; they **do not hand‑write code**.
- After each phase, do a **5‑minute code walkthrough** using the “Explain the generated code” bullets—build mental models without inviting refactor chaos.
- Celebrate the first green test with a dramatic “It’s alive!”

---

## What success looks like
- `uv run uvicorn app.main:app --port 8000` starts cleanly.
- `/chat` streams a sensible reply, uses tools for math/datetime, and performs a handoff for “research.”
- Tests pass locally and in CI; coverage ≥ target; Docker image is lean.

---

## Troubleshooting (the friendly kind)
- If Cursor invents APIs: “Use only the official OpenAI Agents SDK APIs; cite the specific function names you used.”
- If sessions don’t persist: “Add an in‑memory session store keyed by session_id and unit tests covering continuation.”
- If outputs ramble: “Tighten instructions to 2‑3 sentences; prefer bullet points; never exceed 1200 chars.”

---

## Next steps
- Add a **Knowledge tool** (RAG) to ground answers.  
- Try a **WebSocket** UI for real‑time token flow.  
- Hook up tracing dashboards; demos love pretty graphs.

> You now have a chatbot built by **prompt‑driven development** with **TDD**, **ADRs**, and **PR gates**. You wrote prompts; Cursor wrote code; everyone high‑fived. 🖐️

